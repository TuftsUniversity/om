h1. Common Patterns You'll Use with OM

h2. Common Terminology Patterns

Let's say we have xml like this:

<pre>
<outer outerId="hypatia:outer" type="outer type">
  <elementA>valA</elementA>
  <elementB>valB1</elementB>
  <elementB animal="vole">valB2<elementC>
  <elementC type="c type" animal="seagull">valC<elementC>
  <resource type="ead" id="coll.ead" objectId="hypatia:ead_file_asset_fixture">
    <file id="my_ead.xml" format="XML" mimetype="text/xml" size="47570">
      <checksum type="md5">123</checksum>
      <checksum type="sha1">456</checksum>
    </file>
  </resource>
  <resource type="image" id="image" objectId="hypatia:coll_img_file_asset_fixture">
    <file id="my_image.jpg" format="JPG" mimetype="image/jpeg" size="302080">
      <checksum type="md5">789</checksum>
      <checksum type="sha1">666</checksum>
    </file>
  </resource>
</outer>
</pre>

h4. element value

We want an OM term for the value of an element. 

In the Datastream Model:

<pre>  
# defines the expected OM terminology for example xml
class ExampleXMLDS < ActiveFedora::NokogiriDatastream 
  # OM (Opinionated Metadata) terminology mapping 
  set_terminology do |t|
    t.root(:path => "outer", :xmlns => '', :namespace_prefix => nil)
    t.elementA
    t.elB(:path => "elementB", :namespace_prefix => nil)
    t.elC(:path => "elementC", :namespace_prefix => nil)
  end  
end
</pre>

This results in :elementA having a value of "valA" and :elB having two values of "valB1" and "valB2", and :elC having a value of "valC"

h4. element value given a specific attribute value

We want an OM term for the value of an element, but only if the element has a specific attribute value.

In the Datastream Model:

<pre>  
# defines the expected OM terminology for example xml
class ExampleXMLDS < ActiveFedora::NokogiriDatastream 
  # OM (Opinionated Metadata) terminology mapping 
  set_terminology do |t|
    t.root(:path => "outer", :xmlns => '')
    t.elementC(:attributes=>{:animal=>"seagull"}, :namespace_prefix => nil)
    t.here(:path=>"resource", :attributes=>{:type=>"ead"}, :namespace_prefix => nil)
    t.there(:path=>"resource", :attributes=>{:type=>"nowhere"}, :namespace_prefix => nil)
  end  
end 
</pre>

This results in :elementC having a value of "valC" and :here having a value of "123 456", and :there having a value of nil (or is it ""?)

h4. element value given absence of a specific attribute

We want an OM term for an element's value, but only if the element does not have a specific attribute.

<pre>  
# defines the expected OM terminology for example xml
class ExampleXMLDS < ActiveFedora::NokogiriDatastream 
  # OM (Opinionated Metadata) terminology mapping 
  set_terminology do |t|
    t.root(:path => "outer", :xmlns => '', :namespace_prefix => nil)
    t.elementB(:attributes=>{:animal=>:none}, :namespace_prefix => nil)
    t.no_attrib(:path => "elementB", :attributes=>{:animal=>:none}, :namespace_prefix => nil)
  end  
end 
</pre>

This results in both :elementB and :no_attib having the single value "valB1"


h4. attribute value

We want an OM term for an attribute value

<pre>  
# defines the expected OM terminology for example xml
class ExampleXMLDS < ActiveFedora::NokogiriDatastream 
  # OM (Opinionated Metadata) terminology mapping 
  set_terminology do |t|
    t.root(:path => "outer", :xmlns => '', :namespace_prefix => nil)
    t.elementB {
      t.my_attr(:path => {:attribute=>"animal"}, :namespace_prefix => nil)
    }
    t.alternate(:path => "elementB/@animal", :namespace_prefix => nil)
    t.another(:proxy=>[:elementB, :my_attr_])
    t.animal_attrib(:path => {:attribute=>"animal"}, :namespace_prefix => nil)
  end  
end
</pre>

This results in :my_attr, :alternate and :another all having the single value of "vole", and :animal_attrib having the values "vole" and "seagull"


h4. an example with :proxy and :ref

<pre>  
# defines the expected OM terminology for example xml
class ExampleXMLDS < ActiveFedora::NokogiriDatastream 
  # OM (Opinionated Metadata) terminology mapping 
  set_terminology do |t|
    t.root(:path => "outer", :xmlns => '', :namespace_prefix => nil)

    t.resource(:namespace_prefix => nil) {
      t.fedora_pid(:path=>{:attribute=>"objectId"}, :namespace_prefix => nil)
      t.file(:ref=>[:file], :namespace_prefix => nil, :namespace_prefix => nil)
    }
    t.file(:namespace_prefix => nil) {
      t.ds_label(:path=>{:attribute=>"id"}, :namespace_prefix => nil)
      t.size(:path=>{:attribute=>"size"}, :namespace_prefix => nil)
      t.md5(:path=>"checksum", :attributes=>{:type=>"md5"}, :namespace_prefix => nil)
      t.sha1(:path=>"checksum", :attributes=>{:type=>"sha1"}, :namespace_prefix => nil)
    }
    #  really want ead where the type is ead and the file format is XML and the file mimetype is text/xml (and the file id is (?coll_ead.xml ... can be whatever the label of the DS is in the FileAsset object)) 
    t.ead(:ref=>:resource, :attributes=>{:type=>"ead"}) 
    t.image(:ref=>:resource, :attributes=>{:type=>"image"})

    t.ead_fedora_pid(:proxy=>[:ead, :fedora_pid])
    t.ead_ds_label(:proxy=>[:ead, :file, :ds_label])
    t.ead_size(:proxy=>[:ead, :file, :size])
    t.ead_md5(:proxy=>[:ead, :file, :md5])
    t.ead_sha1(:proxy=>[:ead, :file, :sha1])

    t.image_fedora_pid(:proxy=>[:image, :fedora_pid])
    t.image_ds_label(:proxy=>[:image, :file, :ds_label])
    t.image_size(:proxy=>[:image, :file, :size])
    t.image_md5(:proxy=>[:image, :file, :md5])
    t.image_sha1(:proxy=>[:image, :file, :sha1])
  end  
end
</pre>

This results in 
:ead_fedora_pid has value "hypatia:ead_file_asset_fixture"
:ead_ds_label has value "my_ead.xml"
:ead_size has value "47570"
:ead_md5 has value"123"
:ead_sha1 has value "456"

:image_fedora_pid has value "hypatia:coll_img_file_asset_fixture"
:image_ds_label has value "my_image.jpg"
:image_size has value "302080"
:image_md5 has value "789"
:image_sha1 has value "666"


h4. need the value of a child element to select the current element

Let's say we have xml like this:

<pre>
<contentMetadata>
   <resource type="file" id="BU3A5" objectId="val2">
    <file id="BURCH1" format="BINARY">
      <location>content</location>
    </file>
    <file id="BURCH1.html" format="HTML">
      <location>html</location>
    </file>
  </resource>
</contentMetadata>
</pre>

We want an OM term corresponding to the <file> element based on the value of the <location> element.  That is, we want to have a :content term when the value of <location> is "content" and an :html term when the value of <location> is "html".

In the Datastream Model:

<pre>  
# defines the expected OM terminology for example xml
class ExampleXMLDS < ActiveFedora::NokogiriDatastream 
  # OM (Opinionated Metadata) terminology mapping 
  t.root(:path=>"contentMetadata", :xmlns => '', :namespace_prefix => nil) 

  t.resource(:namespace_prefix => nil) {
    t.file(:ref=>[:file], :namespace_prefix => nil)
  }

  t.file(:namespace_prefix => nil) {
    t.location(:path=>"location", :namespace_prefix => nil)
    t.filename(:path=>{:attribute=>"id"}, :namespace_prefix => nil)
    t.format(:path=>{:attribute=>"format"}, :namespace_prefix => nil)
  }
  t.content(:ref=>:file, :path=>'resource/file[location="content"]', :namespace_prefix => nil)
  t.html(:ref=>:file, :path=>'resource/file[location="derivative_html"]', :namespace_prefix => nil)

  t.content_location(:proxy=>[:content, :location])
  t.content_filename(:proxy=>[:content, :filename])
  t.content_format(:proxy=>[:content, :format])

  t.html_location(:proxy=>[:html, :location])
  t.html_filename(:proxy=>[:html, :filename])
  t.html_format(:proxy=>[:html, :format])

end
</pre>


h3. Arguments that can be used in the terminology

e.g. :path, :default_content_path, :namespace_prefix ...

ok if this is a link to the rdoc that describes ALL of these with 


h3. Reserved method names (ie. id_, root_)

Like Nokogiri ...

h3. Namespaces
oxns
document namespaces & node namespaces
_no namespace_ (suppressing oxns in xpath queries)

h3. :ref and :proxy Terms